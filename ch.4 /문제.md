# 서버와 클라이언트 이해

## 서버와 클라이언트 3가지 경우 살펴보기

### 1. 네트워크에서의 서버 - 클라이언트 관계
- **  **: 서비스를 제공  
- **      **: 서비스를 받음
- 네트워크의 서버-클라이언트는 물리적인 장치 간 관계 ( 유무선으로 연결됨 )
  연결된 장치간에는 유의미한 트랙픽이 오고 간다
  이 사이에는 유의미한 트래픽을 주고받는 **애플리케이션** 실행

####   처리
         : 데이터의 이동 흐름, 양
1. **ㅁㅁㅁㅁㅁㅁㅁ**  
   고객을 분산시켜 서버 ㅁㅁ 맞추는 작업. **ㅁㅁㅁ**가 어떤 서버로 보낼지 소프트웨어적으로 해결  

2. **ㅁㅁ**  
   비용이 큰 작업의 결과를 저장 후, **비용이  ㅁㅁ 결과물**로 처리
     
#### 애플리케이션에서의 서버 - 클라이언트 관계
- 애플리케이션 : 운영체제에 설치해 사용하는 모든 응용 프로그램
- 각 서버, 클라이언트에 애플리케이션이 존재하고 이들간의 관계가 요청과 응답

#### 코드에서의 서버 - 클라이언트 관계
- 코드 간에 서버와 클라이언트가 존재하면 의존관계로 간주  
- 서버 코드 변경이 클라이언트 코드 변경을 유발하면 의존관계 발생  

---
<참고 - 예>
pc에 chrome을 접속한 경우
사용자의 행동(요청)에 따른 동작 
ㅁㅁㅁ : 요청이 필요한 동작, 필요없는 동작으로 나뉜다.
후자의 경우 클라이언트가 서버에 요청없이 실행되지만, 
전자의 경우 요청이 필요해 배운 서버에 요청하는 과정이 실행된다.

그렇다면, 후자의 경우 서버는 쉬고 있는걸까?
완전히 쉬는 상태는 아니고 대기, 백그라운드 작업등을 하고 있다.

각 이벤트그의 구분 또한 뒤에서 더 배우게 된다.

---
## 브라우저와 서버: 웹 브라우저와 웹 서버 통신 원리

### 웹 ㅁㅁㅁㅁ와 웹 ㅁㅁㅁㅁㅁㅁ의 차이
- **웹 ㅁㅁㅁㅁ**: 사용자가 원하는 웹 애플리케이션을 서버에서 가져와 **ㅁㅁ**  (도서관 사서)
  -> HTML문서,사진,동영상파일 등 다양한 요소들을 종합하여 보여줌 = "ㅁㅁㅁ"
 ->
   1. 도메인 네임 입력시 dns -> ip 변환
   2. 사용자의 액션에 따른 요청 보냄(웹어플리케이션에)
   3. 응답을 받아 화면에 렌더링 
- **웹 애플리케이션**: **특정 도서**처럼 사용자가 직접 상호작용하며 필요한 정보 제공 (책)

#### 동작 원리
검색창에 url입력시 일어나는 과정을 살펴보
1. 사용자가 URL 입력 → **DNS 서버**에서 도메인 네임을 IP 주소로 변환  
2. IP 주소를 기반으로 라우터를 거쳐 웹 서버에 요청 전달 (주소갖고)  
3. 웹 서버에서 요청 처리 후 응답 전달 (HTML 문서 등)  
4. 웹 브라우저가 화면에 렌더링

+) dns 서버 cmd에서 확인가능 (dns서버 연결은 자동)
+) ip주소를 갖고 출발하면 와이파이 전파나,랜선을 타고 공유기를 거쳐 인터넷 구간을 지남
+) 이 구간에는 라우터가 중간중간에 있고, 라우터는 이 ip주소를 기반으로 다음 경로를 안내해줌(라우터 접속)
+) 잘 전달받으면 개발자 도구에서 확인가

### 키워드
- **요청과 응답**  
- **IP 주소**  

#### IP 주소
- 네트워크상의 주소로, 점(.) 기준 4개의 숫자 조합 (0~255)  각각 약 43억개
- **공인 IP**: 외부에서 접근 가능  
- **사설 IP**: 공유기에 연결된 내부 기기
-  공인 ip 확인방법 : 네이버 검색 ( 인터넷 서비스 제공업체에서 제공 )
-  사설 ip 확인방법 : 명령 프롬프트를 열고 'ipconfig'입력
-  공유기 : 사설,공인ip연결 관리 (핵심기술 : NAT)

  +) 사설 ip 주소는 어떻게 인터넷 접속?
  공유기를 통해, 외부와 통신할때 공인 ip주소를 사용 

#### 로컬호스트 (127.0.0.1)
- 자기 자신을 가리키는 네트워크 표준  
- DNS 서버를 거치지 않고 운영체제 내부에서 처리
  +) 이 원리 좀 어려움
  네트워크를 거치지 않고 pc안에 서버가 있어서 내부에서 처리가능
  이 범위? 가능이유?



## 포트와 NAT
ip주소의 경우 물리적인 장치만 구분할 수 있기에, 애플리케이션 구분 가능한 포트 도입
- **포트**: 애플리케이션 구분을 위해 번호 부여  
- **종류**: well known / 등록된/  동적
- 포트번호를 명시적으로 적어주지 않아도 **해당 프로토콜의 기본 포트**를 요청에 추가해줌**+) http의 경우 다 80이면 구분은 어떻게 하지?, 중복은 발생하지 않게 처리한다는데 어떻게 처리? (웹 호스트이용해서 구분)
---

## 웹 서버와 WAS
### 웹 서버
- 정적인 콘텐츠 제공에 중점  
- 예: HTML, 이미지
 
1 물리적인 형태의 서버 : 네트워크 장비, 데이터 베이스 등이 있어야 데이터를 주고 받을 수 있기에 웹서버
2 웹 "요청"을 받을 수 있는 서버
3 프로그래밍 언어에 의해 특정 로직이 실행 

### WAS (Web Application Server)
- 동적 콘텐츠 처리  
- 서버에 존재하지 않던 데이터를 생성해 반환  

---

## 서버 간 통신
- 한 서버에서 모든 서비스 동작 불가 → 분리  
- HTTP 통신 사용  
- 서비스 분리 이유: 오류 발생 시 개별 처리 가능  

---

## 기타 클라이언트
웹 브라우저말고 다른 클라이언트도 있다~
- **HTTP 클라이언트**: 웹 브라우저 외에도 Postman, curl 등 존재  
- Postman과 curl로도 HTTP 요청 가능  

---
- ## 용어  
- **네트워크 장비**: 라우터, 스위치, 방화벽 등이 서버와 외부 기기 간 통신 지원  
- **데이터베이스**: 서버의 핵심 데이터 저장소로, 효율적 저장과 검색을 위해 물리적으로 가까운 위치에 배치

---
## 요약
- **서버**: 서비스 제공, **클라이언트**: 서비스 소비  
- **웹 브라우저**: 요청과 응답을 통해 콘텐츠 렌더링  
- **IP 주소와 포트**: 네트워크와 애플리케이션 구분  
- **웹 서버 vs WAS**: 정적 vs 동적 콘텐츠  
- **서버 간 통신**: 서비스 분리 및 HTTP 사용


  


## HTTP

 : Hyper Text Transfer Protocol 
   링크 = 텍스트로 이루어져 이를 누르면 웹페이지로 이동함, 이를 하이퍼 텍스트로 부름 
   이 링크를 타고 다니면서 정보를 전송할 수 있는 통신 규약! 
   
   1.1버전 : 안정적으로 자리잡은 버전 -> 2 버전 
   
   =>> 1.1버전 특징 
   
   (1) 클라이언트의 요청이 먼저 시작되어야 함
   (2) 무상태성 : 상태를 가지지 않음. 이전과 다음 요청의 연관관계가 없고 구분하지 않는다.
       사용자가 같더라도 구분하지 않음, 로그인해서 사용자를 구분하고 관리하는 것은 이 프로토콜의 영역이 아니다.즉 상태를 가지지 않는다.
       쿠키 세션 토큰 같은 사용자 구분법으로 사용자 구분.
   (3) 비연결성 : 소켓을 서로 연결하는 과정 . 데이터를 주고 받기 위해 연결하지만 트랜잭션이 끝나면 연결을 끊어버림. 다음 요청시 연결을 다시 맺는다. 매번 커넥션
   을 연결하고 끊는 방식. 
   연결된 클라이언트가 쌓이게 되기 때문에 새로운 클라이언트가 못 연결될 수 있음. 
   매번 맺끊는게 비효율적일 수 있음.
    
   **HTTP 지속 커넥션** search 
   같은 연결을 사용할 수 있다???? 재사용 가능 

   (4) 사람에게 친화적인 규약 : 바이너리 아님

   HTTP 사람이 읽을 수 있는 형태로 정의됨

   차이점(+추가로 더 찾아보기)

   /2버전
- 하나의 커넥션에서 **여러개의 요청**을 **동시에 다중 처리**가능 (요청순서에 맞게 처리 -> v.1 지속커넥션 사용한 것과 다름)
- **헤더를 압축**한다 :: 사람이 읽을 수는 없지만 사이즈는 작아져서 네트워크 효율성은 좋아짐
- 서버에서 예상되는 요청을 **미리** 클라이언트에 전송
  :: 클라이언트가 보통 함께 요청하는건 함께 보내는거.
     html이 요청될때 css,javascript등이 다음에 요청되기때문에  미리 보내두는거!, html페이지와 함께 보내주면 성능상 이점이 생김 
  
   /3버전
  - TCP가아닌UDP사용 (TCP의 핸드쉐이킹 - 오버헤드 , UDP 핸드쉐이킹 과정 없음)
  - TCP의 헤더는 안정적인 데이터 전송을 위해 여러가지 필드를 가지고 있지만,
  - UDP의 헤더는 오직 출발지,목적지 포트 , 데이터의 길이 체크섬 정도만 가지고 있음.
  - HTTP에서는 TCP의 이전 역할을 해서 UDP로 신뢰성있게 데이터를 주고 받으며 속도까지 챙길 수 있었음
 
  - TCP: 데이터 정확도가 중요한 경우 (예: 파일 다운로드, 온라인 뱅킹).
UDP: 속도가 중요한 경우 (예: 실시간 스트리밍, 게임) → 데이터 손실이 약간 있어도 괜찮은 상황.
    
   
 
트랜잭션 : HTTP의 요청과 응답이 하나의 묶음으로 이루어진다는 의미 
::  일반적으로 사용된느 '트랜잭션 표현' = "쪼갤 수 없는 처리" = 쪼개지지 않고 처리되어야 할 단위 이야기 함 
그치만 HTTP 트랜잭션은 쪼개지지 않는 단위가 아니라 **HTTP 요청과 응답**이라는 하나의 묶음에 대한 이야기!

**서버**와 **클라이언트**의 HTTP요청에 응답하는 과정 


개발자 도구에서의 확인가능 

**각 탭의 역할**
Headers : HTTP 헤더에 대한 정보, **요청에 대한 헤더**와 **응답에 대한 헤더**를 나누어서 봄 
Payload : **데이터 전송**에 포함되는 내용의 데이터. HTTP의 요청은 헤더와 바디 부분으로 나뉘는데 요청의 바디에 해당하는 데이터는 탭에서 확인 가능.
Preview : 응답의 **바디**에 포함된 데이터를 보기 좋은 형태의 **미리보기**로 제공. JSON데이터를 자바스크립트 객체 형태로 보여줬던 것이 이 탭에 해당됨.
Response : preview와 동일하게 응답의 **바디**에 포함된 데이터를 보여주지만, 있는 그대로 보여줌.(불친절 버전이라고 생각할 수 있음, 날 것의 데이터 ) 

HTTP요청 헤더 


어떤 요청 메서드? 어떤 식으로 사용된는 지?
GET /backend.html HTTP/1.1

GET : 특정 자원에 대한 조회를 **요청**하는 메서드
HEAD : 바디를 제외한 **헤더 부분만 응답**으로 받는 메서드
POST : **새로운 자원을 생성**을 요청하는 메서드
PUT : 기존에 있던 자원을 요청 바디에 있는 내용으로 **변경**하는 메서드
PATCH : put처럼 변경하는데 전체가 아닌 일부만 변경
DELETE : 특정 자원을 제거
OPTIONS : 해당 경로에서 어떤 HTTP요청 메서드를 사용할 수 있는지 알려줌 

post : 생성하기 
get : 읽기
put : 수정하기 
delete : 삭제하기 

---
각각의 메서드 설명 

좋은 api를 만들기 위해서 적절한 http요청을 지정하는 것이 중요 - 동일한 경로로 여러개의 기능을 사용할 수 있음
적절한 메소드가 무엇인지 고민하는 습관이 중요!!

안전한 메서드
 : 대상이 되는 자원의 상태를 변경하지 않는 메서드 : GET,HEAD,OPTIONS
   (예) 즐겨찾기 서비스라면 즐겨찾기의 이름을 변경하거나, 즐겨찾기의 URL을 변경하지 않는 메서드

 get메서드의 경우 특정URL에 **접속하기만 해도** 요청이 날아갈 수 있는데, 사용자가 접속하기만 했는데 무언가 삭제되고 그러면 위험하다
 그래서 실수로 어떤요청이 날아갈 수 있기때문에 어떤 자원의 상태를 변경할때 get을 사용하는 것은 위험한 api설계이다.

멱등성 메서드
 : 한번 호츌한 것과 여러번 호출한 것이 같은 **자원의 상태**를 가지는 것. 응답의 값이 같은 것이 아님 주의 
  없는 메서드 : POST,PATCH..

글 작성 : 자원의 생성, POST로 함
글 수정 : 이미 수정된 걸 계속 API요청 해도 상태 같음...

GET은 반드시 안전한 메서드.
PUT,DELETE는 멱등성이 있는 메서드.


HEAD메서드와 OPTIONS 메서드
 : 

HTTP 요청 바디와 데이터 전달 방식
 : 데이터를 전달하는 다양한 방식 ajax,form등등등 이 있음 
 요청 바디,URL 통해서 전달도 가능  -> http요청헤더와 바디의 어떤 부분에 담겨 전달되는지

 데이터 전달 방식
 
-  **URL**
https://www.google.com/search?q=%E3%84%B4&oq=%E3%84%B4&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIMCAEQI..
URL의 일부로 데이터를 전송하는 방식 -> 쿼리 파라미터, 쿼리 스트링
 

Query String : ?뒤에 데이터경로의 일부가 적혀있음
path Variable : 특정 id=123인 article을 조회한다는 의미

content type mime
웹 브라우저가 응답결과를 다르게 해석하기에 content type을 잘 작성하는 것이 중요하다


-  **요청바디**

HTTP 응답 헤더와 바디 <><><>

사용중인 응답상태
 

  

